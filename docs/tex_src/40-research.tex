\chapter{Исследовательская часть}

В данном разделе будут измерены и сравнены скорости работы начального и оптимизирующего кодов.

\section{Отдельные замеры скорости работы файловых индексов}

\subsection{Технические характеристики машины, на которой проводились данные замеры}

\begin{itemize}
	\item Операционная система: Manjaro \cite{manjaro} Linux \cite{linux} x86\_64.
	\item Память: 8 GiB.
	\item Процессор: Intel Core™ i7-8550U\cite{intel}.
\end{itemize}

Тестирование проводилось на ноутбуке, включенном в сеть электропитания. Во время тестирования ноутбук был нагружен только встроенными приложениями окружения, окружением, а также непосредственно системой тестирования.

\subsection{Замеры}

В таблице \ref{tab:serialization} и на графике \ref{img:serialization} представлено среднее время сериализации в мс для 2 реализаций файловых индексов в зависимости от количества заголовков (размер в тысячах записей). В таблице \ref{tab:any} и на графике \ref{img:get_any} представлено среднее время запросов первой записи, соответствующей искомому ключу, а в таблице \ref{tab:all} и на графике \ref{img:get_all} представлено среднее время запросов всех записей, соответствующих искомому ключу, в зависимости от количества заголовков (размер в тысячах записей).

\begin{table}[!h]
    \begin{center}
        \begin{tabular}{|c|c|c|}
            \hline
            Размер & B$^+$-дерево & Бинарный поиск \\
            \hline
            50 & 31 & 20\\
            \hline
            100 & 61 & 39\\
            \hline
            200 & 114 & 68\\
            \hline
            500 & 288 & 186\\
            \hline
            1000 & 343 & 309\\
            \hline
            10000 & 7522 & 4821\\
            \hline
        \end{tabular}
    \end{center}
    \caption{\label{tab:serialization} Сравнение среднего времени сериализации для 2 реализаций файловых индексов, размер в тысячах, время в мс}
\end{table}

\imgw{160mm}{serialization}{График зависимости времени сериализации от количества записей для 2 реализаций}

\clearpage

\begin{table}[!h]
    \begin{center}
        \begin{tabular}{|c|c|c|}
            \hline
            Размер & B$^+$-дерево & Бинарный поиск \\
            \hline
            50 & 11 & 98\\
            \hline
            100 & 11 & 110\\
            \hline
            200 & 18 & 115\\
            \hline
            500 & 18 & 135\\
            \hline
            1000 & 18 & 138\\
            \hline
            10000 & 19 & 163\\
            \hline
        \end{tabular}
    \end{center}
    \caption{\label{tab:any} Сравнение среднего времени запросов первого заголовка для 2 реализаций файловых индексов, размер в тысячах, время в мкс}
\end{table}

\imgw{160mm}{get_any}{График зависимости времени поиска от количества записей для 2 реализаций}

\begin{table}[!h]
    \begin{center}
        \begin{tabular}{|c|c|c|}
            \hline
            Размер & B$^+$-дерево & Бинарный поиск \\
            \hline
            50 & 11 & 108\\
            \hline
            100 & 11 & 132\\
            \hline
            200 & 18 & 142\\
            \hline
            500 & 18 & 151\\
            \hline
            1000 & 18 & 161\\
            \hline
            10000 & 19 & 173\\
            \hline
        \end{tabular}
    \end{center}
    \caption{\label{tab:all} Сравнение среднего времени запросов всех заголовков для 2 реализаций файловых индексов, размер в тысячах, время в мкс}
\end{table}

\clearpage

\imgw{160mm}{get_all}{График зависимости времени поиска всех записей для соответствующего ключа от количества записей для 2 реализаций}

\subsection*{Вывод}

В данном подразделе в некоторых случаях реализация B$^+$-дерева оказалась быстрее больше, чем в 9 раз. Однако данный тест не является показательным, потому что в таком эксперименте весь кэш системы в процессе вычислений находится в распоряжении индексов, поэтому B$^+$-дерево им более удачно пользуется. При этом процесс сериализации B$^+$-дерева дольше в среднем на 55\% в связи с тем, что помимо сериализации упорядоченного набора заголовков строится дерево.

\section{Замеры скорости работы в составе кластера}

\subsection{Использование кластера с Pearl}

Для тестирования изменений, связанных со скоростью поиска, можно воспользоваться распределенным хранилищем, использующим в своей основе Pearl --- Bob \cite{bob}. Помимо реализации логики управления кластером, данный проект содержит утилиты для его тестирования.

\subsection{Технические характеристики сервера, на котором проводится тестирование}

\begin{itemize}
	\item Операционная система: Linux \cite{linux} x86\_64.
	\item Память: 64 GiB.
    \item Процессор: Intel® Xeon® Silver 4210R CPU @ 2.40GHz\cite{intel}.
\end{itemize}

\subsection{Конфигурация кластера}

Исследуемый кластер имеет следующую конфигурацию:
\begin{itemize}
    \item один сервер;
    \item 10 дисков;
    \item максимальное количество записей в 1 блобе = 200000;
    \item максимальный размер блоб файла = 10 Гб;
    \item размер записи = 50 Кб.
\end{itemize}

Утилита тестирования будет содержать 24 клиентов, для выполнения одновременных запросов к бобу.

\subsection{Стратегии запросов данных}

Перед непосредственным выполнением запросов утилита сперва формирует заданное количество клиентов, выделяя для каждого свой асинхронный поток и диапазон ключей, которые клиент должен запросить. Диапазон ключей рассчитывается по следующему принципу: утилита получает на вход главный диапазон, который требуется запросить, затем она делит этот диапазон на $m$ равных целых частей, где $m$ -- число клиентов (если невозможно, то последний клиент запросит на $x < m$ запросов больше) и распределяет эти диапазоны между созданными клиентами. В данном эксперименте рассматриваются 2 стратегии запросов данных:
\begin{itemize}
    \item \textit{случайные запросы} --- каждый клиент запрашивает данные из своего диапазона случайным образом;
    \item \textit{упорядоченные запросы} --- клиенты запрашивают данные параллельно, однако каждый клиент запрашивает ключи из своего диапазона последовательно.
\end{itemize}

\subsection{Замеры}

В таблице \ref{tab:rand} и на графике \ref{img:rand} представлено среднее количество ответов кластера в секунду (rps) для случайных запросов ключей в зависимост от размера кластера, а в таблице \ref{tab:seq} и на графике \ref{img:seq} представлено среднее количество ответов кластера в секунду (rps) упорядоченных запросов ключей от размера кластера.

\begin{table}[!h]
    \begin{center}
        \begin{tabular}{|c|c|c|}
            \hline
            Размер кластера, тыс. & B$^+$-дерево, rps & Бинарный поиск, rps \\
            \hline
            2000 & 5000 & 3700\\
            \hline
            4000 & 3100 & 2800\\
            \hline
            6000 & 2650 & 2500\\
            \hline
            8000 & 2150 & 2050\\
            \hline
        \end{tabular}
    \end{center}
    \caption{\label{tab:rand} Среднее количество ответов кластера в секунду (rps) для случайных запросов ключей}
\end{table}

\imgw{160mm}{rand}{График зависимости среднего количества ответов кластера в секунду (rps) для случайных запросов ключей от размера кластера}

\begin{table}[!h]
    \begin{center}
        \begin{tabular}{|c|c|c|}
            \hline
            Размер кластера, тыс. & B$^+$-дерево, rps & Бинарный поиск, rps \\
            \hline
            2000 & 17000 & 12500\\
            \hline
            4000 & 16500 & 11000\\
            \hline
            6000 & 16000 & 11000\\
            \hline
            8000 & 16000 & 10500\\
            \hline
        \end{tabular}
    \end{center}
    \caption{\label{tab:seq} Среднее количество ответов кластера в секунду (rps) для упорядоченных запросов ключей}
\end{table}

\clearpage

\imgw{160mm}{seq}{График зависимости среднего количества ответов кластера в секунду (rps) для последовательных запросов ключей от размера кластера}

\section*{Вывод}

В данном разделе были протестированы старая и новая реализация файловых индексов изолированно от базы данных, а также в составе кластера. Данный эксперимент показал, что в изолированном случае индексы могут быть найдены в 9 раз быстрее, в то время как в составе кластера скорость работы увеличилась не так значительно: в зависимости от видов запросов и степени наполнения кластера скорость работы индексов на основе B$^+$-дерева от 5 до 60\% быстрее.
