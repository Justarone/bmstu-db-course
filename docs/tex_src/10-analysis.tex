\chapter{Аналитическая часть}

\section{Способы организации хранения изображений}

Неструктурированные данные --- данные, которые не соответствуют заранее определённой модели данных\cite{unstr}. Изображения, как было сказано в введении, являются неструктурированными данными, поэтому способы их хранения часто отличаются от способов хранения структурированных данных. 

В исследовании\cite{research} компании Microsoft\cite{microsoft} приведено сравнение 2 способов хранения неструктурированных данных:

\begin{enumerate}
    \item в виде отдельных файлов в файловой системе;
    \item в виде BLOB'ов в базе данных (BLOB\cite{blob} --- массив двоичных данных).
\end{enumerate}

В результате исследования было выяснено, что поиск и чтение неструктурированных данных при использовании базы данных выполняется быстрее, нежели при хранении в виде файлов в файловой системе. В данной работе рассматривается формат хранения изображений в виде массивов двоичных данных в нереляционных базах данных\cite{nosql}.

\section{Использование нереляционных баз данных}

Использование в данной работе нереляционных баз данных обусловлено тем, что требуется хранить неструктурированные данные. Такие данные не содержат информацию о связях между собой, поэтому зачастую каждому объекту, описывающему неструктурированные данные, ставится в соответствие некоторый ключ, по которому данный объект можно идентифицировать: это может быть имя файла в системе (если данные хранятся в виде файлов) или сгенерированные специальным образом хэш\cite{hash} или число. Данный идентификатор в свою очередь может быть использован в качестве ссылки на изображение в других частях приложения, с помощью которой можно получать доступ к требуемому изображению.

Несмотря на то, что многие современные реляционные базы данных предоставляют возможность хранения массивов двоичных данных (например, в PostgreSQL\cite{psql} это реализовано в виде отдельного модуля "lo"\cite{lo}), у такого решения есть недостатки. 

Если хранить изображения на одном сервере и в одной базе данных с остальными (структурированными) данными, то такой подход обладает минусами монолитной архитектуры:
\begin{itemize}
    \item сложное горизонтальное масштабирование \cite{scal};
    \item имеется единая точка отказа\cite{dp};
    \item в большинстве случаев структурированные данные вынуждены хранится на ёмких, но более медленных накопителях, ввиду больших требований к объему памяти для неструктурированных данных.
\end{itemize}

Данные недостатки могут быть устранены за счет использование нескольких серверов: структурированные данные находятся на одном сервере и хранят идентификатор для неструктурированных данных, которые хранятся на другом сервере, и запрашивают их с другого сервера, используя идентификатор. Такой подход использует принципы сервер-ориентированной архитектуры. При таком проектировании сервер с неструктурированными данными хранит пары <<ключ-значение>>, и использование реляционных БД в таком случае избыточно в сравнении с нереляционными БД (в частности БД <<ключ-значение>>\cite{kvstore}).

Таким образом, в качестве NoSQL БД для хранения изображений в данной работе будут рассматриваться БД <<ключ-значение>>.

\section{Базы данных <<ключ-значение>>}

База данных <<ключ-значение>> --- парадигма хранения данных, предназначенная для хранения, извлечения и управления ассоциативными массивами (структура данных, более известная сегодня как словарь или хеш-таблица) \cite{kvstore}. Примером таких баз данных могут послужить Redis \cite{redis} и Tarantool \cite{tarantool}.

Базы данных <<ключ-значение>> можно разделить на 2 группы:
\begin{enumerate}
    \item \textbf{база данных, которая полностью размещается в памяти} (англ. \textit{"in-memory database"}) --- такая база данных использует для хранения только оперативную память сервера;
    \item \textbf{постоянная база данных} (англ. \textit{"on-disk database"} или \textit{"persitent database"}) --- база данных, хранящая большую часть данных в файлах.
\end{enumerate}

Несмотря на то, что база данных, которая полностью размещается в памяти, обладает более высокой скоростью чтения и записи данных \cite{inmem}, использования таких баз данных в рамках поставленной задачи невозможно из-за следующих причин:
\begin{itemize}
    \item при перезагрузке сервера все данные будут потеряны;
    \item объем данных ограничен объемом оперативной памяти.
\end{itemize}

Ввиду этих недостатков использование базы данных, которая полностью размещается в памяти, невозможно, в связи с чем будет использоваться постоянная база данных. Среди постоянных баз данных большинство ориентировано на работу с SSD накопителями \cite{ssd}. Примером таких баз данных могут послужить RocksDB\cite{rocks}, sled\cite{sled}. Однако у SSD накопителей есть недостаток: ограниченное число циклов перезаписи. В связи с этим в данной работе рассматривается база данных ориентированная на работу с HDD\cite{hdd}.

В качестве исследуемой и улучшаемой базы данных используется база данных <<ключ-значение>> Pearl \cite{pearl}, удовлетворящая всем описанным выше требованиям:
\begin{itemize}
    \item является постоянной базой данных;
    \item ориентирована на работу с HDD.
\end{itemize}

\section{База данных Pearl}

Для анализа и оптимизации поиска требуется:
\begin{enumerate}
    \item рассмотреть архитектуру базы данных;
    \item проанализировать текущий алгоритм поиска;
    \item рассмотреть альтернативы и выбрать наиболее подходящую.
\end{enumerate}

\subsection{Архитектура}

На рисунке \ref{img:arch} представлена UML-диаграмма, описывающая архитектуру Pearl.

\clearpage

\imgw{170mm}{arch}{Архитектура Pearl}

\subsection{Текущий алгоритм поиска}

При запросе данных по ключу (как уже было описано ранее, в качестве данных выступают массивы бинарных данных, описывающие изображения) есть 2 варианта:
\begin{enumerate}
    \item найти все данные с заданным ключом;
    \item найти первую попавшуюся запись с заданным ключом.
\end{enumerate}

Разница в алгоритмах поиска в этих 2 вариантах заключается в том, что в 1 варианте, в случае нахождения записи с искомым ключом поиск прекращается, в то время как в случае поиска всех записей, проверяются все \texttt{Blob} объекты. Алгоритм поиска в отдельном объекте \texttt{Blob} одинаковый для обоих вариантов, поэтому рассмотрение для поиска для второго варианта не снижает общность анализа.

Примечание: Pearl можно настроить таким образом, чтобы он добавлял только уникальные записи, возвращая ошибку на дубликаты, но в таком случае цена добавления возрастает (потому что для каждой записи потребуется делать еще и запрос на чтение). В таком случае возвращаемый набор записей для 2 вариантов будет одинаковым.

Объект \texttt{Blob} в документации называют просто \textit{блобом}. Также, в Pearl вводится понятие \textit{активного блоба}. Активный блоб --- блоб, индексы которого хранятся в виде структуры \texttt{InMemoryIndex} в оперативной памяти компьютера. У блобов, которые не являются активными, индексы хранятся в файле в виде упорядоченного массива структур \texttt{RecordHeader}. Значения, хранящиеся по ключу, называют \textit{записью}, в качестве индексов используются \textit{заголовки записей}. В данной работе будут использоваться данные обозначения.

\subsubsection{Общий алгоритм поиска}

При поиске ключа в Pearl сначала просматриваются индексы активного блоба (структура \texttt{InMemoryIndex}). При наличии ключа среди индексов активного блоба структура возвращает заголовок записи, в котором имеется смещение и размер требуемого данного в блоб файле. В таком случае из файла с блобами по указанному смещению и размеру читаются данные, обрабатываются и возвращаются пользователю базы данных.

В случае, если в активном блобе запись с требуемым ключом не была найдена, то поиск выполняется в индексах неактивных блобов. Данные индексы описываются структурой \texttt{FileIndex}. Если какой-то блоб содержит запись с искомым ключом, то индекс такого блоба вернет заголовок записи, что позволит из соответствующего блоб-файла считать запись, соответствующую искомому ключу. Если же после просмотра всех блобов ни один из них не вернул заголовок записи, значит, ключ отсутствует в базе данных.

\subsubsection{Алгоритм поиска для индексов активного блоба}

Как уже было сказано выше, активный блоб хранит индексы в оперативной памяти. Для хранения используется структура данных из стандартной библиотеки языка Rust\cite{rust} -- \texttt{BTreeMap}\cite{btreemap}. Данная структура данных является B-деревом\cite{btree} --- сбалансированное дерево поиска. 

 Данное дерево было открыто в 1970 году, и на момент написания данной работы оно используется в базах данных, например, в PostgreSQL\cite{btreepsql}. 

\subsubsection{Алгоритм поиска для индексов неактивного блоба}

Для неактивного блоба индексы хранятся в файле в виде упорядоченного массива, то есть для любых 2 заголовков записей заголовок с меньшим смещением в файле соответствует записи с меньшим ключом. На рисунке \ref{img:ind1} изображена структура файла с индексами.

\imgw{170mm}{ind1}{структура файла с индексами}

Поиск для неактивного блоба реализован с помощью алгоритма бинарного поиска\cite{binsearch}.

\subsection{Способы оптимизации алгоритма поиска}

В рассмотренном алгоритме поиска узким местом является поиск индексов на диске: в то время как в хранилище может быть только один активный блоб, неактивных блобов может быть много больше одного, что приведет к тому, что в каком-то состоянии системы поиск в неактивных блобах будет занимать наибольшую часть времени поиска, в связи с чем требуется проанализировать способы оптимизации хранения и поиска индексов в файле.

В качестве альтернативы хранения и поиска индексов в файле можно предложить 2 структуры данных:
\begin{itemize}
    \item Хэш-таблица;
    \item B$^+$-дерево.
\end{itemize}

\subsubsection{Хранение в виде хэш-таблицы}

При организации индексов на основе хэш-таблицы ключи преобразуются в хэши\cite{hash}. Хэшом называют некоторое значение, получаемое для ключа как значение некоторой функции, называемой хэш-функцией. Вычисленное значение определенным образом может быть преобразовано в указатель на некоторую часть хэш-таблицы, хранящую нужную запись. Амортизированная сложность\cite{compl} поиска для таких индексов --- O(1).

На рисунке \ref{img:hash} изображен пример простой хэш-таблицы, где в качестве хэш-функции для ключей-чисел применяется функция $$f(x) = mod_5(17 \cdot x + 11)$$ хэш-таблица представлена массивом, а получаемое значение служит индексом в этом массиве.

\clearpage
\imgw{90mm}{hash}{Пример хэш-таблицы}

Однако у хэш-таблиц имеется ряд ограничений:
\begin{itemize}
    \item отсутствие возможности поиска в интервале (потому что последовательность, получающаяся после применения хэш-функцией может не быть упорядоченной по возрастанию ключей);
    \item отсутствие возможности выборки по префиксу (потому что в общем случае хэш считается для всего ключа);
    \item возможные длительные вычисления хэш-функции;
    \item возможные коллизии\cite{hash}.
\end{itemize}

Индексы на основе хэш-таблиц сегодня используются в некоторых <<key-value>> базах данных, например, в Redis\cite{redis}.

\subsubsection{Хранение в виде B$^+$-дерева}

Для сохранения упорядоченности ключей часто используется B-дерево и его модификации, одной из которых является B$^+$-дерево. К идее B$^+$-дерева можно прийти итеративными шагами, начиная с бинарного дерева.

\textit{m-way-деревом} называют дерево поиска, узлы которого могут иметь до $m$ потомков\cite{mway}. оно обладает теми же свойствами, что и бинарное дерево, которое является частным случаем m-way-дерева с параметром $m = 2$. На рисунке \ref{img:4way} изображен пример m-way-дерева с параметром $m = 4$.

\imgw{110mm}{4way}{Пример m-way-дерева с параметром $m = 4$}

B-дерево -- m-way-дерево, обладающее следующими дополнительными свойствами:
\begin{itemize}
    \item корень имеет как минимум 2 поддерева (или в дереве только 1 вершина);
    \item каждая вершина, которая не является листом или корнем, должна иметь от $\lceil\frac{m}{2}\rceil$ до $m$ детей;
    \item количество ключей у каждой вершины на 1 меньше, чем количество ее непустых детей;
    \item все листья находятся на одном уровне.
\end{itemize}

На рисунке \ref{img:btree} приведен пример B-дерева с максимальным числом детей равным 5.

\imgw{170mm}{btree}{Пример B-дерева с максимальным числом детей равным 5}


Высота B-дерева в худшем случае\cite{hbtree}:
\begin{equation}
    \overline{height}_{btree} = log_{\lceil\frac{m}{2}\rceil - 1}\left(\frac{n + 1}{2}\right)
\end{equation}

В то время как высота бинарного дерева в лучшем случае:
\begin{equation}
    height_{binary} = \lfloor log_2(n) \rfloor + 1
\end{equation}

При $m >= 7$ B-дерево в худшем случае имеет высоту не больше, чем бинарное дерево в лучшем случае (а при достаточно больших $n$ имеет сильно меньшую высоту).

Идея эффективности B-дерева в сравнении с обычным бинарным деревом поиска (или бинарным поиском в массиве) заключается в сокращении числа медленных операций чтения с диска: данные читаются блоками (вершинами, которые содержат до $m-1$ ключей) и так как высота B-дерева меньше, чем высота бинарного дерева поиска, то и медленных операций чтения будет меньше, что приводит к более быстрой скорости работы.

B$^+$-дерево похоже на B-дерево, однако имеет важные отличия:
\begin{itemize}
    \item вся информация, связанная с ключом, хранится в листовых вершинах;
    \item листовые вершины связаны друг с другом в связный список.
\end{itemize}

На рисунке \ref{img:bptree} приведен пример B$^+$-дерева с максимальным числом детей равным 5.

\imgw{170mm}{bptree}{Пример B$^+$-дерева с максимальным числом детей равным 5}

Высота B$^+$-дерева в худшем случае\cite{hbptree}:
\begin{equation}
    \overline{height}_{bptree} = log_{\lceil\frac{m}{2}\rceil}(n)
\end{equation}

Важно отметить некоторые преимущества и недостатки B$^+$-дерева.

Преимущества:
\begin{itemize}
    \item вершины, которые не являются листьями, содержат только информацию, связанную с деревом (не содержат информацию, связанную с ключом), что при условии ограниченности размера блока памяти для вершины, приводит к тому, что вершины B$^+$-дерева могут содержать большее количество ключей.
    \item возможность работы с интервалами ключей (ввиду связанных листовых вершин и содержания в листьях всех ключей);
\end{itemize}

Недостатки:
\begin{itemize}
    \item вершины, которые не являются листьями, входят в дерево дважды (в общем случае при одинаковом количестве детей у вершин высота B+-дерева больше, чем высота B-дерева).
\end{itemize}

\section*{Вывод}

В данном разделе были рассмотрены:
\begin{itemize}
    \item способы хранения неструктурированных данных на сервере;
    \item базы данных, предоставляющие возможность хранения неструктурированных данных;
    \item база данных Pearl, ее архитектура и алгоритм поиска записи по ключу;
    \item способы оптимизации поиска в базе данных Pearl.
\end{itemize}

Было выяснено, что для ускорения операции поиска в базе данных Pearl нужно оптимизировать поиск в неактивных блобах, и было предложено 2 варианта оптимизации хранения заголовков в файлах индексов для неактивных блобов, один из которых (B$^+$-дерево) позволяет сохранить свойство упорядоченности хранения. Учитывая также все перечисленные в разделе преимущества, в данной работе для оптимизации операции поиска реализуется хранение в виде B$^+$-дерева.
